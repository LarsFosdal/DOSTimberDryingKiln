{$I CODEDEFS.PAS} {Include code generation definitions}
{$G-}{We don't want this unit to contain 286 code}

UNIT LFsysInf;  {Req. TP6 or above}

INTERFACE

{--- CPU ID routines --------------------------------------------------------}
(*
  Even if a program is compiled with compiler directive {$G+},
  it does not check the type of processor at runtime to determine
  whether it is 286-compatible.
  Trying to execute 80286/386/486 instructions on an 8086/88
  will lock up the computer. This routine shows how to check for
  the type of chip at runtime.

  If you want to put code like this in a program using compiler
  directive {$G+}, create test and halt code in the initialization
  section of the *FIRST* unit in the program's USES clause.
  This first unit must be compiled with {$G-}

  Lars Fosdal, Alfsen & Gunderson A/S,  8. Jan. 1991

*)
CONST
  CPUtypeUnknown = $FFFF;
  CPUtype86  = 0;
  CPUtype186 = 1;
  CPUtype286 = 2;
  CPUtype386 = 3;
  CPUtype486 = 4;
  CPUName : ARRAY [-1..4] OF String[9] =
    ('Unknown','8086/88','80186/188','80286','80386','80486');

FUNCTION CPUtype:Integer;

IMPLEMENTATION
USES Dos;


{--- CPU type detecting routines --------------------------------------------}

FUNCTION CanRun286Code : Boolean; ASSEMBLER;
{This doesn't work on a 286 !  Ok on a 386DX}
ASM
  PUSHF             {Copy flags to BX}
  POP     BX
  AND     BX,0FFFH  {Clear flags 12..15 (Not used in 8086/88/186/188)}
  PUSH    BX        {Set flags according to BX}
  POPF
  PUSHF             {Copy flags to BX again}
  POP     BX
  AND     BX,0F000H {Clear flags 0..11 (common for all processors)
  CMP     BX,0F000H {Check if flags 12..15 are still zero}
  MOV     AX,0      {If so, return 0=False ): Can't run 286 code}
  JZ      @@1
  MOV     AX,1      {Flags<>zero: Return 1=True ): 286 found}
 @@1: {RET-code is embedded in "ASM END;" structure}
END; {FUNC CanRun286Code}


{--- FUNC CPUtype ---}
{ is based on the Int6 system on 186/286/386/486 CPU's }


VAR
  OldInt6Vec : Pointer;

PROCEDURE INT6Handler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);
INTERRUPT; ASSEMBLER;
{ - INT6 is generated by illegal OpCodes on 186/286/386/486's }
ASM
  dec     word ptr ss:[bp][12]     { dec cx, i.e. Set semaphore}
  add     word ptr ss:[bp][18],3   { point ip past invalid opcode}
END;

FUNCTION CPUType:Integer;
{ - CPU type detector for TP6 by Lars Fosdal, Oslo, NORWAY
    Based on an .ASM example by Robert Collins, Anaheim, CA, USA

   Output:  CPU type
            0 = 8086/8088
            1 = 80186/80188
            2 = 80286
            3 = 80386
            4 = 80486
         FFFF = Unknown CPU type
}
LABEL
  CPU_8086_exit, _exit;
BEGIN
  ASM
   xor     ax,ax                   { clear CPU type return register}
   push    sp                      { save SP on stack to look at}
   pop     bx                      { get SP saved on stack}
   cmp     bx,sp                   { if 8086/8088, these values will differ}
   jnz     CPU_8086_exit           { yep, they differ: jump}
  END;
  GetIntVec(6,OldInt6Vec);         { Store old Int6 Vector}
  SetIntVec(6,@Int6Handler);       { Set out own Int6 handler}

  INLINE($C8/$04/$00/$00);          {enter   4,0    create stack frame }
  ASM
    mov     ax,4                    { initialize CPU flag=4 (80486)}
    xor     cx,cx                   { initialize semaphore}
  END;
  INLINE($0f/$C1/$D2);  {xadd dx,dx  ; 486 Instr.}
  ASM
    jcxz    _exit                   { Skipped on Int6 ): Not 486}
    dec     ax                      { set 80386 semaphore}
    inc     cx                      { CX=0}
  END;
  Inline($0F/$20/$C2);  { mov edx,cr0  ; 80386 Instr.}
  ASM
    jcxz    _exit                   { Skipped on Int6 ): Not 386}
    dec     ax                      { set 80286 semaphore}
    inc     cx                      { CX=0}
  END;
  INLINE($0F/$01/$E2);              { smsw dx   80286 Instr.}
  ASM
    jcxz    _exit                   { Skipped on Int6 ): Not 286}
    dec     ax                      { set 80186 semaphore}
    inc     cx                      { CX=0}
  END;
  INLINE($C1/$E2/$05);   {shl dx,5    80186/80188 Instr.}
  ASM
    jcxz    _exit                   { Skipped on Int6 ): Not 186/188}
    dec     ax                      { set UNKNOWN_CPU semaphore}
    { If we came here, God knows what happened :-) }
  _exit:
  END;
  INLINE($C9);              {leave    Restore stack frame }
  ASM
    push ax                         { Save ax }
  END;
  SetIntVec(6,OldInt6Vec);          { Restore Old Int6 vector }
  ASM
    pop ax                          { Restore ax }
  END;

CPU_8086_exit:
  ASM
    mov @Result,ax                  { CPUtype:=ax }
  END;
END;{FUNC CPUType}

(*

Article: 535 of comp.sys.intel
Path: ifi!nuug!sunic!mcsun!uunet!ogicse!orstcs!jacobs.cs.orst.edu!danw
From: danw@jacobs.cs.orst.edu (Dan Whitaker)
Newsgroups: comp.sys.intel
Subject: CODE that can tell a 386DX from a 386SX
Message-ID: <21239@orstcs.CS.ORST.EDU>
Date: 22 Oct 90 22:24:27 GMT
Sender: usenet@orstcs.CS.ORST.EDU
Reply-To: danw@jacobs.cs.orst.edu (Dan Whitaker)
Organization: Oregon State University - CS - Corvallis Oregon
Lines: 56



For all of you that have been looking for a fool proof way to
tell a 386DX from a 386SX, there it is. (Source code included)

This program works on all existing 386's.  It should be assume that 
when Advanced Micro Devices (AMD) comes out with it's 386sx chip that 
it will not have the bug in it that allows this program to work.

The program displays a simple message that tells what kind of 
processor you are working on.  This is quick and dirty code, so
be careful.

I assume that anyone that uses this code is would use it wisely.  By
that I mean, don't purposely disable your code so it won't work on an SX 
or something like that.

FLAME ON [ I hope AMD kicks Intels butt in it's current lawsuit,  Intel 
deserves it for the way it treats it's smaller customers.] FLAME OFF

Dan Whitaker   wk (503) 757-0934  FAX (503) 757-7350


The following code is written in Borlands Turbo Assembler
=======================================================
   DOSSEG
   .MODEL MEDIUM
   .386P
   .STACK 100h
   .DATA
have386dx DB 'You have a 386DX',13,10,'$'
have386sx DB 'You have a 386sx',13,10,'$'
   .CODE
   mov  eax,CR0                 ;Read in the CR0 register
   and  eax,0ffefh              ;set the 5th bit to 0
   mov CR0,eax                  ;write out modified register to reset CR0
   mov eax,CR0                  ;Read it back in to see if it changed
   and eax,00010h               ;set register to 0 if 5th bit was zero
   jnz sxchip                   ;see if it is sx

   mov ax,@data                 ;lets display the dx message
   mov ds,ax                    ;set DS to point to the data segment
   mov ah,9                     ;DOS print string function
   mov dx,OFFSET have386dx      ;point to dx message
   int 21h                      ;display the message
   jmp exit
sxchip:
   mov  ax,@data
   mov  ds,ax                       ;set DS to point to the data segment
   mov  ah,9                        ;DOS print string function
   mov  dx,OFFSET have386sx         ;point to sx message
   int  21h                         ;display message
exit:
   mov  ah,4ch                      ;DOS terminate program function
   int  21h                         ;terminate the program
   END
=======================================================



*)
END.
